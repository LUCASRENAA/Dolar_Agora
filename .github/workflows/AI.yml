# Este workflow analisa os findings de Code Scanning do GitHub usando o modelo TinyLlama
# rodando localmente em um container Ollama.
name: Analisar Findings de Seguran√ßa com TinyLlama

on:
  # O 'pull_request_target' √© usado para garantir que o GITHUB_TOKEN tenha permiss√µes de escrita
  # (pull-requests: write) necess√°rias para comentar no PR.
  pull_request_target:
    types: [opened, reopened, synchronize]
    branches:
      - '*'
  # Adicione 'workflow_dispatch' para poder rodar manualmente para testes
  workflow_dispatch:

permissions:
  # Necess√°rio para ler o c√≥digo (checkout) e os eventos de seguran√ßa
  contents: read
  security-events: read
  # Necess√°rio para comentar no Pull Request
  pull-requests: write

jobs:
  analyze-findings:
    name: Analisar Findings de Seguran√ßa com TinyLlama
    # Usamos um runner ubuntu-latest que j√° vem com Docker pr√©-instalado
    runs-on: ubuntu-latest
    
    steps:
      # Etapa 1: Checkout do c√≥digo do Pull Request
      # Usamos o SHA do HEAD do PR para checkout, garantindo a seguran√ßa ao usar pull_request_target
      - name: Checkout reposit√≥rio com seguran√ßa
        uses: actions/checkout@v4
        with:  # CORRE√á√ÉO: Adicionando os dois pontos (:)
          # √â crucial verificar o c√≥digo que est√° sendo proposto
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 1

      # Etapa 2: Instalar Ollama e TinyLlama em background
      - name: Iniciar Ollama e Pull TinyLlama
        # O docker-cli est√° dispon√≠vel no runner. Iniciamos o Ollama expondo a porta 11434
        run: |
          echo "üê≥ Iniciando container Ollama em background..."
          # Roda o Ollama em detached mode, expondo a porta 11434
          docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama
          
          # Puxa o modelo TinyLlama. Isso pode levar um tempo.
          echo "‚¨áÔ∏è Puxando modelo tinyllama..."
          docker exec ollama ollama pull tinyllama
          
          # Espera um pouco para garantir que o servi√ßo de API esteja ativo
          echo "‚è±Ô∏è Aguardando 15 segundos para o Ollama inicializar a API..."
          sleep 15
          
          # Health check b√°sico: verifica se o modelo est√° carregado (opcional, mas bom)
          docker exec ollama ollama run tinyllama "Hello" || true

      # Etapa 3: Baixar findings de Code Scanning
      - name: Baixar findings de Code Scanning
        id: download_findings
        run: |
          # Cria o diret√≥rio para armazenar os JSONs
          mkdir -p findings
          
          # Baixa apenas os alerts de Code Scanning que s√£o abertos (state=open)
          # A l√≥gica de parsing original √© mais adequada para Code Scanning.
          echo "üì• Baixando findings de Code Scanning..."
          curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/code-scanning/alerts?state=open" \
            -o findings/code-scanning.json
            
          # Verifica se o arquivo foi baixado e se √© um JSON v√°lido. 
          # Se o resultado for 403/404 ou um JSON vazio, o jq vai falhar, mas o script segue.
          if ! jq . findings/code-scanning.json > /dev/null 2>&1; then
              echo "[]" > findings/code-scanning.json
              echo "‚ö†Ô∏è Erro ou resultado vazio/inv√°lido ao baixar Code Scanning. Criando JSON vazio."
          fi

      # Etapa 4: Analisar findings com TinyLlama
      - name: Analisar findings com TinyLlama e Comentar no PR
        # Substitui a sintaxe HERE-DOC por cria√ß√£o de arquivos tempor√°rios para maior robustez
        run: |
          file="findings/code-scanning.json"
          type="Code Scanning"
          
          echo "üîé Analisando findings de ${type}..."
          
          # Conta o n√∫mero de findings
          count=$(jq length "$file")

          if [ "$count" -eq 0 ]; then
            echo "‚úÖ Nenhum finding de ${type} encontrado."
            exit 0
          fi
          
          # Loop por cada finding encontrado
          for i in $(seq 0 $(($count - 1))); do
            finding=$(jq -r ".[$i]" "$file")

            # Extra√ß√£o de campos (ajustei para ser mais robusto com os caminhos do jq)
            number=$(echo "$finding" | jq -r '.number // "N/A"')
            created_at=$(echo "$finding" | jq -r '.created_at // "N/A"')
            description=$(echo "$finding" | jq -r '.rule.description // "N/A"')
            severity=$(echo "$finding" | jq -r '.rule.severity // "N/A"')
            location_path=$(echo "$finding" | jq -r '.most_recent_instance.location.path // "N/A"')
            location_line=$(echo "$finding" | jq -r '.most_recent_instance.location.start_line // "N/A"')
            message_text=$(echo "$finding" | jq -r '.most_recent_instance.message.text // "N/A"')
            html_url=$(echo "$finding" | jq -r '.html_url // "N/A"')
            help_uri=$(echo "$finding" | jq -r '.rule.help_uri // "N/A"')
            
            # --- 1. Criar e preparar o Prompt ---
            # Cria o arquivo de prompt em formato multi-linha (substituindo HERE-DOC)
            # Adicionamos '--' ao printf para evitar que h√≠fens no in√≠cio da string sejam interpretados como op√ß√µes
            printf "A vulnerability was found in the repository's Code Scanning. Below are the details:\n\n" > prompt.txt
            printf -- "- Finding ID: %s\n" "$number" >> prompt.txt
            printf -- "- Created At: %s\n" "$created_at" >> prompt.txt
            printf -- "- Description: %s\n" "$description" >> prompt.txt
            printf -- "- Severity: %s\n" "$severity" >> prompt.txt
            printf -- "- File Path: %s\n" "$location_path" >> prompt.txt
            printf -- "- Line Number: %s\n" "$location_line" >> prompt.txt
            printf -- "- Message: %s\n\n" "$message_text" >> prompt.txt
            printf "Do you consider this a false positive? Justify your answer briefly in Portuguese, focusing on the file and line number provided.\n\n" >> prompt.txt
            printf "For reference, here is the rule documentation: %s\n" "$help_uri" >> prompt.txt
            printf "GitHub Finding Link: %s" "$html_url" >> prompt.txt
            
            # Escapa o conte√∫do do prompt para JSON e salva no arquivo final
            escaped_prompt=$(jq -Rs . prompt.txt)
            
            # Monta o payload JSON para o cURL (a chave 'prompt' usar√° o conte√∫do escapado)
            echo "{\"model\": \"tinyllama\", \"stream\": false, \"prompt\": $escaped_prompt}" > payload.json
            
            # --- 2. Chamar a API do Ollama com retries ---
            MAX_RETRIES=3
            HTTP_CODE="0"
            result=""

            for attempt in $(seq 1 $MAX_RETRIES); do
                echo "üîå Tentativa $attempt de conex√£o com Ollama..."
                response=$(curl -s -X POST http://localhost:11434/api/generate \
                  -H "Content-Type: application/json" \
                  -d @payload.json \
                  --write-out "%{http_code}" \
                  --output response.json)
                
                HTTP_CODE="${response: -3}"
                
                if [ "$HTTP_CODE" -eq 200 ]; then
                    echo "‚úÖ Sucesso na conex√£o com Ollama."
                    break
                fi
                
                echo "‚ùå Ollama retornou c√≥digo HTTP $HTTP_CODE. Tentando novamente em 5 segundos..."
                sleep 5
                
                if [ "$attempt" -eq "$MAX_RETRIES" ]; then
                    echo "üö® Falha ao conectar ao Ollama ap√≥s $MAX_RETRIES tentativas."
                    result="N√£o foi poss√≠vel obter a an√°lise da IA devido a falha de conex√£o com o TinyLlama."
                    break
                fi
            done

            # Se o curl foi bem-sucedido (c√≥digo 200), extrai a resposta
            if [ "$HTTP_CODE" -eq 200 ]; then
                result=$(jq -r '.response // .error // "Resposta da IA em formato inesperado."' response.json)
            fi

            echo "üß† Resultado da IA para Finding #$number: $result"
            
            # --- 3. Comentar no Pull Request (tamb√©m sem HERE-DOC) ---
            if [[ "${{ github.event_name }}" == "pull_request_target" ]]; then
              
              # Cria o corpo do coment√°rio em Markdown em um arquivo tempor√°rio
              printf "### ü§ñ An√°lise Autom√°tica da TinyLlama (Code Scanning)\n\n" > comment_body.md
              printf "**Finding ID:** #%s\n" "$number" >> comment_body.md
              printf "**Severidade:** %s\n" "$severity" >> comment_body.md
              printf "**Caminho:** \`%s:%s\`\n\n" "$location_path" "$location_line" >> comment_body.md
              printf "**Descri√ß√£o do Finding:**\n" >> comment_body.md
              printf "> %s\n\n" "$description" >> comment_body.md
              printf "**Resultado da IA:**\n" >> comment_body.md
              printf "\`\`\`\n%s\n\`\`\`\n\n" "$result" >> comment_body.md
              printf "[üîó Ver finding no GitHub](%s)\n" "$html_url" >> comment_body.md
              
              # Escapa o corpo do coment√°rio para ser injetado no payload JSON do GitHub API
              escaped_body=$(jq -Rs . comment_body.md)

              # Monta o payload JSON para o cURL (a chave 'body' usar√° o conte√∫do escapado)
              echo "{\"body\": $escaped_body}" > comment_payload.json

              # Envia o coment√°rio para o Pull Request
              curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Content-Type: application/json" \
                  -X POST \
                  -d @comment_payload.json \
                  "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments"
              
              echo "üìù Coment√°rio postado no PR #${{ github.event.pull_request.number }}"

            else
              echo "‚è≠Ô∏è Ignorando postagem de coment√°rio. O workflow n√£o est√° rodando em um evento pull_request_target."
            fi
            
          done


      # Etapa 5: Limpar o ambiente Ollama
      - name: Parar e remover ambiente TinyLlama
        if: always()
        run: |
          echo "üõë Parando e removendo container Ollama..."
          docker stop ollama || true
          docker rm ollama || true
